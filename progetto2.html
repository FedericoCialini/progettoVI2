<!DOCTYPE html>
<html>
<head>
	<title>progetto2</title>
	<meta charset="utf-8">
	<script type="text/javascript" src="d3/d3.min.js"></script>
</head>
<body>
	<script type="text/javascript">
        
        
    //---------------- constants ----------------//

        
	const workarea_width = 1600;
	const workarea_height = 900;
	const workarea_center_x = workarea_width/2;
	const workarea_center_y = workarea_height/2;
        
	const distance = 80;
    const cluster_rect_width = 60;
    const cluster_rect_height = 60;
    const node_circle_r = 20;  // -> diameter is 2*r
    const cluster_background_opacity = 0.1
    
    const animations_duration = 300 // in milliseconds
    
    
    
    //---------------- workarea ----------------//
    
    var currentZoomScale = 1;
    var zoom = d3.zoom().on("zoom", function() {
            currentZoomScale = d3.event.transform.k;
            workarea.attr("transform", d3.event.transform);
        });
    
    var container = d3.select("body")
		.append("svg")
		.attr("width", workarea_width).attr("height", workarea_height)
        .attr("style", "outline: medium solid black;")
        .call(zoom)
        .on("dblclick.zoom", null);
        
	var workarea = container.append("g");
        
    function resize_container() {
        container.attr("width", window.innerWidth-20).attr("height", window.innerHeight-20);
    }
        
    resize_container();
        
    window.addEventListener("resize", resize_container);
        
        
        
    //---------------- support functions ----------------//
        
        
    function getRandomIntInRange(min, max) {
        min = Math.ceil(min);
        max = Math.ceil(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
        
    function generateIntArrayWithRange(start, end) {
        var array = [];
        for(var i=start; i<=end; i++) {
            array.push(i);
        }
        return array;
    }
        
    function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;

        while (0 !== currentIndex) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    }
        
    function centerRectX(x) {
        return x - cluster_rect_width/2;
    }
        
    function centerRectY(y) {
        return y - cluster_rect_height/2;
    }

        
        
    //---------------- plane ----------------//
        
        
    var id2plane = {};
    
    // this class represent a logical plane, through which we're going to display a cluster's elements
    class Plane {

        constructor(this_node, element_list, is_root_node) {
            this.node = this_node;
            this.numberOfElements = element_list.length;
            this.elements = element_list;
            this.elementCoords = this.generateElementsCoords();
            this.is_root_node = is_root_node;
            this.isDisplayed = true;
        }
        
        generateElementsCoords() {
            var element2coords = [];
            var Xcoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            var Ycoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            for(var i=0; i<this.numberOfElements; i++) {
                var x = Xcoords[i];
                var y = Ycoords[i];
                element2coords[i] = [x,y];
            }
            return element2coords;
        }
        
        displayChildren() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;

            this.elements.forEach(function(d, i) {
                var childId = thisId+","+i;
                if(d[0]!=null){
                    var child_node = workarea
                        .append("rect")
                        .attr("id",childId)
                        .attr("class","cluster_node")
                        .attr("x", centerRectX(x + (this.elementCoords[i][0] - 1) * distance))
                        .attr("y", centerRectY(y + (this.elementCoords[i][1] - 1) * distance))
                        .attr("rx", 10)
                        .attr("ry", 10)
                        .attr("width", cluster_rect_width)
                        .attr("height", cluster_rect_height)
                        .attr("fill", "red")
                        .attr("stroke-width", 2)
                        .attr("stroke", "black")
                        .on("click", explode)
                        ._groups[0][0];
                    // I need to update the child cluster's plane node if it already exists
                    if(id2plane.hasOwnProperty(childId)) {
                        id2plane[childId].node = child_node;
                    }
                }
                else {
                    var node = workarea
                        .append("g")
                        .attr("id",childId)
                        //.attr("class","node")
                        .attr("info", d)
                        .on("click", info);
                    node
                        .append("circle")
                        .attr("id",childId)
                        .attr("class","node")
                        //.attr("info", d)
                        .attr("cx", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("cy", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("r", node_circle_r)
                        .attr("fill", "yellow")
                        .attr("stroke-width", 2)
                        .attr("stroke", "black")
                        //.on("click", info);
                    node
                        .append("text")
                        .attr("id",childId)
                        .attr("class","node")
                        .attr("x", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("y", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("font-family","sans-serif")
                        .style("text-anchor", "middle")
                        .text(d)
                        .style("font-size", function(d) {
                            var d2csf = 1/Math.sqrt(2);  // d2csf = diameter_2_circumscribed_square_factor
                            var v1 = 2*node_circle_r * d2csf;
                            var v2 = (v1 / this.getComputedTextLength() * 24) * d2csf;
                            return Math.min(v1, v2) + "px";
                        })
                        .attr("dy", ".35em");
                }
            }, this);
        }
        
        displayBackgroundCluster() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;
            return workarea
                .append("rect")
                .attr("id",thisId)
                .attr("class","cluster_bg")
                .attr("x", x - distance/2)
                .attr("y", y - distance/2)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", this.elementCoords.length * distance)
                .attr("height", this.elementCoords.length * distance)
                .attr("fill", "blue")
                .attr("fill-opacity", cluster_background_opacity)
                .attr("stroke-width", 2)
                .attr("stroke", "blue")
                .attr("stroke-opacity", cluster_background_opacity * 2)
                .on("dblclick", implode);
        }
        
        // this is still in WIP (as in it's not working yet...)
        /*panToExplodedCluster() {
            var x = parseInt(this.node.attributes.x.value);
            var y = parseInt(this.node.attributes.y.value);
            
            var tx = x + this.elementCoords.length * distance / 2;
            var ty = y + this.elementCoords.length * distance / 2;

            workarea.transition().duration(1000)
                .attr("x", tx)
                .attr("x", ty);
        }*/
        
        getParentClustersIds(thisId) {
            var clusterIds = [];
            while(thisId.includes(",")) {
                var i = thisId.lastIndexOf(",");
                thisId = thisId.substring(0, i);
                if(thisId != "0") { clusterIds.push(thisId); }
            }
            return clusterIds;
        }
        
        updateOtherCoordsAfterExplode() {
            var thisId = this.node.attributes.id.value;
            var this_x = parseInt(this.node.attributes.x.value);
            var this_y = parseInt(this.node.attributes.y.value);
            var delta = (this.elementCoords.length-1) * distance;
            
            var toTranslate = workarea.selectAll("*").filter(function() {
                var elem = d3.select(this);
                var is_of_right_class = elem.attr("class") === "node" || elem.attr("class") === "cluster_node" || elem.attr("class") === "cluster_bg";
                return is_of_right_class && !elem.attr("id").startsWith(thisId);
            });
            toTranslate.attr("x", function(d, i) {
                var xStr = d3.select(this).attr("x");
                if(xStr === null) { // if it's null it's because it's a circle!
                    var cx = parseInt(d3.select(this).attr("cx"));
                    if(cx > this_x) { d3.select(this).attr("cx", cx + delta); }
                    return xStr;
                }
                var x = parseInt(xStr);
                if(x > this_x) { return x + delta; }
                else { return x; }  
            }).attr("y", function(d, i) {
                var yStr = d3.select(this).attr("y");
                if(yStr === null) {
                    var cy = parseInt(d3.select(this).attr("cy"));
                    if(cy > this_y) { d3.select(this).attr("cy", cy + delta); }
                    return yStr;
                }
                var y = parseInt(d3.select(this).attr("y"));
                if(y > this_y) { return y + delta; }
                else { return y; }  
            })
            
            // I also need to enlarge the parent cluster(s) 
            var parentIds = this.getParentClustersIds(thisId);
            parentIds.forEach(function(id, i) {
                var parent = d3.select("[id='"+id+"']");
                parent.attr("width", parseInt(parent.attr("width"))+delta);
                parent.attr("height", parseInt(parent.attr("height"))+delta);
            });
            
        }
        
        getDisplayedChildrenClustersAddedSize(thisId) {
            var totalAddedSize = 0;
            for(var id in id2plane) {
                var child =id2plane[id];
                if(id != thisId && id.startsWith(thisId) && child.isDisplayed) {
                    var addedSize = (child.elementCoords.length-1) * distance;
                    totalAddedSize += addedSize;
                    child.isDisplayed = false;  // this child will be closed!
                }
            }
            return totalAddedSize;
        }
        
        updateOtherCoordsAfterImplode() {
            var thisId = this.node.attributes.id.value;
            var this_x = parseInt(this.node.attributes.x.value);
            var this_y = parseInt(this.node.attributes.y.value);
            var delta = (this.elementCoords.length-1) * distance;
            delta += this.getDisplayedChildrenClustersAddedSize(thisId);
            
            var toTranslate = workarea.selectAll("*").filter(function() {
                var elem = d3.select(this);
                var is_of_right_class = elem.attr("class") === "node" || elem.attr("class") === "cluster_node" || elem.attr("class") === "cluster_bg";
                return is_of_right_class && !elem.attr("id").startsWith(thisId);
            })
            toTranslate.attr("x", function(d, i) {
                var xStr = d3.select(this).attr("x");
                if(xStr === null) {
                    var cx = parseInt(d3.select(this).attr("cx"));
                    if(cx > this_x) { d3.select(this).attr("cx", cx - delta); }
                    return xStr;
                }
                var x = parseInt(xStr);
                if(x > this_x) { return x - delta; }
                else { return x; }  
            }).attr("y", function(d, i) {
                var yStr = d3.select(this).attr("y");
                if(yStr === null) {
                    var cy = parseInt(d3.select(this).attr("cy"));
                    if(cy > this_y) { d3.select(this).attr("cy", cy - delta); }
                    return yStr;
                }
                var y = parseInt(d3.select(this).attr("y"));
                if(y > this_y) { return y - delta; }
                else { return y; }  
            })
            
            // I also need to reduce the parent cluster(s) size
            var parentIds = this.getParentClustersIds(thisId);
            parentIds.forEach(function(id, i) {
                var parent = d3.select("[id='"+id+"']");
                parent.attr("width", parseInt(parent.attr("width"))-delta);
                parent.attr("height", parseInt(parent.attr("height"))-delta);
            });
        }
        
        displayPlane() {
            // if this is the root cluster node
            if(this.is_root_node) {
                this.displayChildren()
                
            // if this is NOT the root cluster node
            } else {
                var bg = this.displayBackgroundCluster();
                this.displayChildren();
            }
            if(!this.is_root_node) {
                this.updateOtherCoordsAfterExplode();
                panToElement(bg);
            }
            this.isDisplayed = true;
        }
        
        hidePlane() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(workarea.select("[id='"+thisId+"']").attr("x")) + distance/2 - cluster_rect_width/2;
            var y = parseInt(workarea.select("[id='"+thisId+"']").attr("y")) + distance/2 - cluster_rect_height/2;
            workarea.selectAll("[id^='"+thisId+"']").remove();
            
            var new_node = workarea.append("rect")
                .attr("id",thisId)
                .attr("class","cluster_node")
                .attr("x", x)
                .attr("y", y)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", cluster_rect_width)
                .attr("height", cluster_rect_height)
                .attr("fill", "red")
                .attr("stroke-width", 2)
                .attr("stroke", "black")
                .on("click", explode);
            
            this.node = new_node._groups[0][0];
            
            this.updateOtherCoordsAfterImplode();
            panToElement(new_node);
            this.isDisplayed = false;
        }
        
    }
        
        
        
    //---------------- main ----------------//

	
	var graph = [];
	d3.json("clusters.json").then(function(data) {
		graph[0] = data;
		workarea.selectAll(".rect")
			.data(data)
			.enter()
            .append("g")
            .attr("id",0)
            .attr("class","plane")
            .attr("x", workarea_center_x)
			.attr("y", workarea_center_y)
        var thisId = "0";
		var thisIdAsPath = [0];
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);
        var this_node = workarea.select("[id='"+thisId+"']")._groups[0][0];
		var plane = new Plane(this_node,thisJsonSubtree,true);
        id2plane[thisId] = plane;
		plane.displayPlane();
    });

	function retrieveElementFromGraphByPathId(path){   //path as to be list: [0,1,0]
		var i = 0;
		var g = graph[0];
		while (path[i]!=null) {
			if(path.length==i+1){
				return g[path[i]];
			}
			else {
				g = g[path[i]];
				i=i+1;
			}
		}
		return null;
	}

	function idStringToList(string){
		var i = 0;
		var list = [];
		var buffer = "";
		while (string[i]!=null){
			if(string[i]!=","){
				buffer = buffer + string[i]
			}
			else {
				list.push(buffer);
				buffer = "";
			}
			i=i+1;
		}
		list.push(buffer);
		return list;
	}

	function info(){
		console.log(this.attributes.id.value+";"/*+this.attributes.x.value+","+this.attributes.y.value+";"*/+this.attributes.info.value);
	}

	function explode(event){
		var thisId = this.attributes.id.value;
		var thisIdAsPath = idStringToList(thisId);
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);

        if(!id2plane.hasOwnProperty(thisId)) {
            var plane = new Plane(this,thisJsonSubtree,false);
            id2plane[thisId] = plane;
            plane.displayPlane();
        } else {
            var plane = id2plane[thisId];
            plane.displayPlane();
        }
		this.remove();
	}
                
    function implode(event){
        var thisId = this.attributes.id.value;
		var thisIdAsPath = idStringToList(thisId);
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);

		plane = id2plane[thisId];
        plane.hidePlane();
    }
        
        
        
    //---------------- animations ----------------//
        
        
    function panToElement(elem) {
        var x = parseInt(elem.attr("x"));
        var y = parseInt(elem.attr("y"));
        var width = parseInt(elem.attr("width"));
        var height = parseInt(elem.attr("height"));
        
        var tx = (-width/2 - x) * currentZoomScale + container.attr("width")/2;
        var ty = (-height/2 - y) * currentZoomScale + container.attr("height")/2;
                          
        workarea.transition()
            .duration(animations_duration)
            .attr("transform", "translate("+tx+","+ty+")scale("+currentZoomScale+")")
            .on("end", function() {
                container.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(currentZoomScale));
            });
    }

	</script>
</body>
</html>