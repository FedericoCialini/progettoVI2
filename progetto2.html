<!DOCTYPE html>
<html>
<head>
	<title>progetto2</title>
	<meta charset="utf-8">
	<script type="text/javascript" src="d3/d3.min.js"></script>
</head>
<body>
	<script type="text/javascript">

	const workarea_width = 1600;
	const workarea_height = 900;
	const workarea_center_x = workarea_width/2;
	const workarea_center_y = workarea_height/2;
        
	const distance = 100;
    const cluster_rect_width = 60;
    const cluster_rect_height = 60;
    const node_circle_r = 20;  // -> diameter is 2*r
    const cluster_background_opacity = 0.1
    
    //--------------------------//
    
    var container = d3.select("body")
		.append("svg")
		.attr("width", workarea_width).attr("height", workarea_height)
        .attr("style", "outline: medium solid black;")
        .call(d3.zoom().on("zoom", function () {
            workarea.attr("transform", d3.event.transform);
        }))
        .on("dblclick.zoom", null);
        
	var workarea = container.append("g");
        
    function resize_container() {
        container.attr("width", window.innerWidth-20).attr("height", window.innerHeight-20);
    }
        
    resize_container();
        
    window.addEventListener("resize", resize_container);
        
    //--------------------------//
        
    function getRandomIntInRange(min, max) {
        min = Math.ceil(min);
        max = Math.ceil(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
        
    function generateIntArrayWithRange(start, end) {
        var array = [];
        for(var i=start; i<=end; i++) {
            array.push(i);
        }
        return array;
    }
        
    function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;

        while (0 !== currentIndex) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    }
        
    function centerRectX(x) {
        return x - cluster_rect_width/2;
    }
        
    function centerRectY(y) {
        return y - cluster_rect_height/2;
    }

    //--------------------------//
        
    var id2plane = {};
    
    // this class represent a logical plane, through which we're going to display a cluster's elements
    class Plane {

        constructor(this_node, element_list, is_root_node) {
            this.node = this_node;
            this.numberOfElements = element_list.length;
            this.elements = element_list;
            this.elementCoords = this.generateElementsCoords();
            this.is_root_node = is_root_node;
        }
        
        generateElementsCoords() {
            var element2coords = [];
            var Xcoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            var Ycoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            for(var i=0; i<this.numberOfElements; i++) {
                var x = Xcoords[i];
                var y = Ycoords[i];
                element2coords[i] = [x,y];
            }
            return element2coords;
        }
        
        displayChildren() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;

            this.elements.forEach(function(d, i) {
                if(d[0]!=null){
                    workarea
                        .append("rect")
                        .attr("id",thisId+","+i)
                        .attr("class","cluster_node")
                        .attr("x", centerRectX(x + (this.elementCoords[i][0] - 1) * distance))
                        .attr("y", centerRectY(y + (this.elementCoords[i][1] - 1) * distance))
                        .attr("rx", 10)
                        .attr("ry", 10)
                        .attr("width", cluster_rect_width)
                        .attr("height", cluster_rect_height)
                        .attr("fill", "red")
                        .attr("stroke-width", 2)
                        .attr("stroke", "black")
                        .on("click", explode);
                }
                else {
                    var node = workarea
                        .append("g")
                        .attr("id",thisId+","+i)
                        //.attr("class","node")
                        .attr("info", d)
                        .on("click", info);
                    node
                        .append("circle")
                        .attr("id",thisId+","+i)
                        .attr("class","node")
                        //.attr("info", d)
                        .attr("cx", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("cy", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("r", node_circle_r)
                        .attr("fill", "yellow")
                        .attr("stroke-width", 2)
                        .attr("stroke", "black")
                        //.on("click", info);
                    node
                        .append("text")
                        .attr("id",thisId+","+i)
                        .attr("class","node")
                        .attr("x", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("y", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("font-family","sans-serif")
                        .style("text-anchor", "middle")
                        .text(d)
                        .style("font-size", function(d) {
                            var d2csf = 1/Math.sqrt(2);  // d2csf = diameter_2_circumscribed_square_factor
                            var v1 = 2*node_circle_r * d2csf;
                            var v2 = (v1 / this.getComputedTextLength() * 24) * d2csf;
                            return Math.min(v1, v2) + "px";
                        })
                        .attr("dy", ".35em");
                }
            }, this);
        }
        
        displayBackgroundCluster() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;
            workarea
                .append("rect")
                .attr("id",thisId)
                .attr("class","cluster_bg")
                .attr("x", x - distance/2)
                .attr("y", y - distance/2)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", this.elementCoords.length * distance)
                .attr("height", this.elementCoords.length * distance)
                .attr("fill", "blue")
                .attr("fill-opacity", cluster_background_opacity)
                .attr("stroke-width", 2)
                .attr("stroke", "black")
                .on("dblclick", implode);
        }
        
        // this is still in WIP (as in it's not working yet...)
        panToExplodedCluster() {
            var x = parseInt(this.node.attributes.x.value);
            var y = parseInt(this.node.attributes.y.value);
            
            var tx = x + this.elementCoords.length * distance / 2;
            var ty = y + this.elementCoords.length * distance / 2;

            workarea.transition().duration(1000)
                .attr("x", tx)
                .attr("x", ty);
        }
        
        updateOtherCoordsAfterExplode() {
            var thisId = this.node.attributes.id.value;
            var this_x = parseInt(this.node.attributes.x.value);
            var this_y = parseInt(this.node.attributes.y.value);
            var delta = (this.elementCoords.length-1) * distance;
            
            var toTranslate = workarea.selectAll("*").filter(function() {
                var elem = d3.select(this);
                var is_of_right_class = elem.attr("class") === "node" || elem.attr("class") === "cluster_node" || elem.attr("class") === "cluster_bg";
                return is_of_right_class && !elem.attr("id").startsWith(thisId);
            });
            toTranslate.attr("x", function(d, i) {
                var x = parseInt(d3.select(this).attr("x"));
                if(x > this_x) { return x + delta; }
                else { return x; }      
            })
            .attr("y", function(d, i) {
                var y = parseInt(d3.select(this).attr("y"));
                if(y > this_y) { return y + delta; }
                else { return y; }   
            });
            
            /*var nodesToTranslate = workarea.selectAll("*").filter(function() {
                var elem = d3.select(this);
                var is_of_right_class = elem.attr("class") === "node";
                return is_of_right_class && !elem.attr("id").startsWith(thisId);
            });
            nodesToTranslate.each(function(d, i) {
                var x = 0;
                var y = 0;
                if(x > this_x) { x = x + delta; }
                if(y > this_y) { y = y + delta; }
                d3.select(this).style("transform", "translate("+x+","+y+")");
            });*/       
        }
        
        updateOtherCoordsAfterImplode() {
            var thisId = this.node.attributes.id.value;
            var this_x = parseInt(this.node.attributes.x.value);
            var this_y = parseInt(this.node.attributes.y.value);
            var delta = (this.elementCoords.length-1) * distance;
            
            var toTranslate = workarea.selectAll("*").filter(function() {
                var elem = d3.select(this);
                var is_of_right_class = elem.attr("class") === "node" || elem.attr("class") === "cluster_node" || elem.attr("class") === "cluster_bg";
                return is_of_right_class && !elem.attr("id").startsWith(thisId);
            })
            toTranslate.attr("x", function(d, i) {
                var x = parseInt(d3.select(this).attr("x"));
                if(x > this_x) { return x - delta; }
                else { return x; }  
            }).attr("y", function(d, i) {
                var y = parseInt(d3.select(this).attr("y"));
                if(y > this_y) { return y - delta; }
                else { return y; }  
            })
            toTranslate.selectAll("circle").attr("cx", function(d, i) {
                var x = parseInt(d3.select(this).attr("cx"));
                if(x > this_x) { return x - delta; }
                else { return x; }  
            }).attr("cy", function(d, i) {
                var y = parseInt(d3.select(this).attr("cy"));
                if(y > this_y) { return y - delta; }
                else { return y; }  
            })
        }
        
        displayPlane() {
            // if this is the root cluster node
            if(this.is_root_node) {
                this.displayChildren()
                
            // if this is NOT the root cluster node
            } else {
                this.displayBackgroundCluster();
                this.displayChildren();
            }
            if(!this.is_root_node) {
                this.updateOtherCoordsAfterExplode();
            }
            this.panToExplodedCluster();
        }
        
        hidePlane() {
            var thisId = this.node.attributes.id.value;
            workarea.selectAll("[id^='"+thisId+"']").remove();
            
            var x = parseInt(this.node.attributes.x.value);
            var y = parseInt(this.node.attributes.y.value);
            workarea.append("rect")
                .attr("id",thisId)
                .attr("class","cluster_node")
                .attr("x", x)
                .attr("y", y)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", cluster_rect_width)
                .attr("height", cluster_rect_height)
                .attr("fill", "red")
                .attr("stroke-width", 2)
                .attr("stroke", "black")
                .on("click", explode);
            
            this.updateOtherCoordsAfterImplode();
        }
        
    }
        
    //--------------------------//

	
	var graph = [];
	d3.json("clusters.json").then(function(data) {
		graph[0] = data;
		workarea.selectAll(".rect")
			.data(data)
			.enter()
            .append("g")
            .attr("id",0)
            .attr("class","plane")
            .attr("x", workarea_center_x)
			.attr("y", workarea_center_y)
        var thisId = "0";
		var thisIdAsPath = [0];
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);
        var this_node = workarea.select("[id='"+thisId+"']")._groups[0][0];
		var plane = new Plane(this_node,thisJsonSubtree,true);
        id2plane[thisId] = plane;
		plane.displayPlane();
    });

	function retrieveElementFromGraphByPathId(path){   //path as to be list: [0,1,0]
		var i = 0;
		var g = graph[0];
		while (path[i]!=null) {
			if(path.length==i+1){
				return g[path[i]];
			}
			else {
				g = g[path[i]];
				i=i+1;
			}
		}
		return null;
	}

	function idStringToList(string){
		var i = 0;
		var list = [];
		var buffer = "";
		while (string[i]!=null){
			if(string[i]!=","){
				buffer = buffer + string[i]
			}
			else {
				list.push(buffer);
				buffer = "";
			}
			i=i+1;
		}
		list.push(buffer);
		return list;
	}

	function info(){
		console.log(this.attributes.id.value+";"+this.attributes.x.value+","+this.attributes.y.value+";"+this.attributes.info.value);
	}

	function explode(event){
		var thisId = this.attributes.id.value;
		var thisIdAsPath = idStringToList(thisId);
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);

        if(!id2plane.hasOwnProperty(thisId)) {
            var plane = new Plane(this,thisJsonSubtree,false);
            id2plane[thisId] = plane;
            plane.displayPlane();
        } else {
            var plane = id2plane[thisId];
            plane.displayPlane();
        }
		this.remove();
	}
                
    function implode(event){
        var thisId = this.attributes.id.value;
		var thisIdAsPath = idStringToList(thisId);
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);

		plane = id2plane[thisId];
        plane.hidePlane();
    }

	</script>
</body>
</html>