<!DOCTYPE html>
<html>
<head>
	<title>progetto2</title>
	<meta charset="utf-8">
	<script type="text/javascript" src="lib/d3/d3.min.js"></script>
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin">
</head>
<body link="37c6ff">   <!--link="42a5f5"-->
    <p hidden><input type="file" id="file-selector"></p>
	<script type="text/javascript"> 
        
        
        
    //---------------- constants ----------------//
        

	const workarea_width = 1600;
	const workarea_height = 900;
	const workarea_center_x = workarea_width/2;
	const workarea_center_y = workarea_height/2;
        
	const distance = 80;
    const cluster_rect_width = 60;
    const cluster_rect_height = 60;
    const node_circle_r = 20;  // -> diameter is 2*r
    
    const animations_duration = 300; // in milliseconds
    
    const panOnExplode = true;
    const panOnImplode = true;
    
    const hueRange = 360;   //HSL
    const nodeHue = 60;
    const nodeSaturation = 100;
    const clusterSaturation = 85;
    const lightness = 50;
        
    const base_bg_opacity = 0.25;
    const max_bg_opacity = 1;
    const bg_opacity_decay = 1 - (1/(max_bg_opacity/base_bg_opacity));

    const examples = [["graphs/small.json"],["graphs/medium.json"],["graphs/big.json"]];

    const defaultGraph = examples[1];
        
    const menu_bg_color = "#36393f"
    const menu_stroke_color = "#202225"
    const menu_text_color = "#eaeaeb"
    
        
    
    //---------------- workarea ----------------//
        
    
    var currentZoomScale = 1;
    var zoom = d3.zoom().on("zoom", function() {
            currentZoomScale = d3.event.transform.k;
            workarea.attr("transform", d3.event.transform);
        });
    
    var container = d3.select("body")
		.append("svg")
		.attr("width", workarea_width).attr("height", workarea_height)
        .attr("style", "outline: medium solid black;")
        .call(zoom)
        .on("dblclick.zoom", null);
        
    var workarea = container.append("g");    
    
    function resize_container() {
    	var innerWidth = window.innerWidth-20;
    	var innerHeight = window.innerHeight-20;
        //var oldContainerWidth = container.attr("width");
        //var oldContainerHeight = container.attr("height");
        container.attr("width",innerWidth).attr("height",innerHeight);
        if(typeof id2plane !== 'undefined') panAndZoomToRootPlaneCenter(id2plane['0']);
        //panAndZoomToCurrentWorkareaCenter(oldContainerWidth, oldContainerHeight, innerWidth, innerHeight);
    }
        
    resize_container();
        
    window.addEventListener("resize", resize_container);
        
    
        
    //---------------- menu ----------------//
        
        
    function generateHamburger(color, stroke_color) {
        container.selectAll(".hamburger").remove();
        
        var hamburger = container.append("g").attr("class", "hamburger");
        hamburger.append("rect")
                    .attr("x", 10)
                    .attr("y", 10)
                    .attr("width", 50)
                    .attr("height", 50)
                    .attr("opacity", 0.0)
        hamburger.append("rect").attr("fill", color)
                    .attr("x", 10)
                    .attr("y", 10)
                    .attr("width", 50)
                    .attr("height", 10)
                    .attr("stroke",stroke_color).attr("stroke-width",2)
        hamburger.append("rect").attr("fill", color)
                    .attr("x", 10)
                    .attr("y", 30)
                    .attr("width", 50)
                    .attr("height", 10)
                    .attr("stroke",stroke_color).attr("stroke-width",2)
        hamburger.append("rect").attr("fill", color)
                    .attr("x", 10)
                    .attr("y", 50)
                    .attr("width", 50)
                    .attr("height", 10)
                    .attr("stroke",stroke_color).attr("stroke-width",2)
        hamburger.on("click", function(){showListMenu(menuIsVisible)});
    }
        
    function changeHamburgerColors(color, stroke_color) {
        hamburger = container.select(".hamburger")
        hamburger.selectAll("rect")
                .attr("fill", color)
                .attr("stroke", stroke_color)
        hamburger.moveToFront()   
    }
    
    generateHamburger("black", null);

    var menuIsVisible = false;
    var creditsIsVisible = false;
	var infoIsVisible = false;
    var listJsonIsVisible = false;
    var currentJson;
    var small,medium,big,download,info,credits,load;

    var fileSelector = document.getElementById('file-selector');
    fileSelector.addEventListener('change', (event) => {
                var fileList = event.target.files;
                var file = fileList[0];
                const reader = new FileReader();
                reader.addEventListener('load', event => {
                    var json = event.target.result;
                    clearWorkarea();
                    loadGraph([json]);
                });
                reader.readAsDataURL(file);
            });

    function clearWorkarea(){
        workarea.selectAll('*').remove();
        container.selectAll(".menu").remove();
        menuIsVisible = false;
    }

    function showListMenu(thisMenuIsVisible){

    	if(thisMenuIsVisible){
            changeHamburgerColors("black", null);
    		container.selectAll(".menu").remove();
    		menuIsVisible = false;
    	}

    	else {
            
            var sfondo = container.append("rect").attr("fill", menu_bg_color).attr("stroke", menu_stroke_color).attr("stroke-width",3)
                    .attr("class","menu").attr("x",0 ).attr("y",0).attr("width", workarea_width/4).attr("height", workarea_height*3/4).attr("opacity",0.9);
            
    		var list = container.append("foreignObject").attr("class","menu").attr("x",0 ).attr("y",50)
                .attr("width", workarea_width/4).attr("height", workarea_height*3/4).append("xhtml:body").append("ul").style("line-height","2em")
                .style("list-style","none").style("color", menu_text_color).style("font-size", "34px").style("text-shadow","2px 2px #000000").style("font-family","Ubuntu");
            var zero = 0;
            load = list.append("li").html("Load graph:").append("ul").style("list-style","none");
            small = load.append("li").html("small example").on("click", function(){
                    clearWorkarea();
                    changeHamburgerColors("black", null);
                    loadGraph(examples[0]);});
            medium = load.append("li").html("medium example").on("click", function(){
                    clearWorkarea();
                    changeHamburgerColors("black", null);
                    loadGraph(examples[1]);});
            big = load.append("li").html("big example").on("click", function(){
                    clearWorkarea();
                    changeHamburgerColors("black", null);
                    loadGraph(examples[2]);});
            load.append(function(){return fileSelector;});
            download = list.append("li").html("Download graph").on("click", downloadGraph);
	    	info = list.append("li").html("Help").on("click", function(){printInfo(infoIsVisible);});
			credits = list.append("li").html("Credits").on("click", function(){printCredits(creditsIsVisible);});
            
            changeHamburgerColors(menu_text_color, "black");

			menuIsVisible = true;
    	}
    	
    }  
	

	function printInfo(thisInfoIsVisible){

		if(!thisInfoIsVisible){

	        var textString =  "- circles = nodes <br><br>"
                textString += "- curved rectangles = clusters <br><br>"
                textString += "- left click on a cluster to expand it <br><br>"
                textString += "- double-click on an exploded cluster to implode it (as well as implode all of its inner exploded clusters) <br><br>"
                textString += "- zoom-in/out with the mouse wheel <br><br>"
                textString += "- hold left click and drag the cursor to pan <br><br>"
                textString += "- click on any of the Load graph options to load a new example, or upload your own graph <br><br>"
                textString += "- Download graph lets you download the JSON file of the currently drawn graph <br><br>"
                textString += "- JSON graph format: two name/value pairs, clusters and edges <br><br>"
                textString += "--- clusters: a list of node numbers and lists representing the tree structure of the clustered graph <br><br>"
                textString += "--- edges: adjacency lists representing directed edges between nodes";

	        var plane = container.append("rect")
	        		.attr("class","info")
	                .attr("fill", menu_bg_color)
	                .attr("stroke", menu_stroke_color)
	                .attr("stroke-width",3)
	                .attr("x", window.innerWidth-500)
	                .attr("y", 0)
	                .attr("width", 500)
	                .attr("height", window.innerHeight-102)
	                .attr("opacity",0.9)
	                .on("click",removeInfoArea);
	        
	        var htmlBody = container.append("foreignObject")
	        		.attr("class","info")
	                .attr("x", window.innerWidth-500)
	                .attr("y", 0)
	                .attr("width", 480)
	                .attr("height", window.innerHeight-102)
	                .on("click",removeInfoArea)
	                .append("xhtml:body")
	                .style("color", menu_text_color)
	                .style("font-size", "22px")
	                .style("text-shadow","2px 2px #000000")
	                .style("font-family","Ubuntu")
	                .style("line-height","1.25em")
	                .on("click",removeInfoArea);

	        htmlBody.html(textString).on("click",removeInfoArea);

	        infoIsVisible = true;

	    	} else {

	    		removeInfoArea();
				infoIsVisible = false;

	    	}

	}

	function removeInfoArea(){

        container.selectAll(".info").remove();
		infoIsVisible = false;

    }

	function printCredits(thisCreditsIsVisible){

		if(!thisCreditsIsVisible){

	        var textString =  "Authors: Luca Emili & Matteo Cesari<br>"
                textString += "Project made for <a href='https://www.uniroma3.it/en'>Roma Tre</a>'s <a href='https://www.dia.uniroma3.it/~infovis/'>Information Visualization course</a>, academic year 2019-2020";

	        var plane = container.append("rect")
	        		.attr("class","credits")
	                .attr("fill", menu_bg_color)
	                .attr("stroke", menu_stroke_color)
	                .attr("stroke-width",3)
	                .attr("x", 0)
	                .attr("y", window.innerHeight-100)
	                .attr("width", window.innerWidth)
	                .attr("height", 100)
	                .attr("opacity",0.9)
	                .on("click",removeCreditsArea);

	        /*var textArea = container.append("text")
	        		.attr("class","credits")
	                .attr("x", window.innerWidth/2)
	                .attr("y", window.innerHeight-40)
	                .attr("font-family","Ubuntu")
	                .style("text-anchor", "middle")
	                .text(textString)
	                .style("font-size", 50)
	                .attr("fill", menu_text_color)
	                .style("text-shadow","2px 2px #000000")
	                .style("font-family","Ubuntu")
	                .on("click",removeCreditsArea);*/
            
            var htmlBody = container.append("foreignObject")
	        		.attr("class","credits")
	                .attr("x", 0)
	                .attr("y", window.innerHeight-100)
	                .attr("width", window.innerWidth)
	                .attr("height", 100)
	                .on("click",removeCreditsArea)
	                .append("xhtml:body")
	                .style("color", menu_text_color)
	                .style("font-size", "22px")
	                .style("text-shadow","2px 2px #000000")
	                .style("font-family","Ubuntu")
	                .style("line-height","1.25em")
                    .style("text-align", "center")
	                .on("click",removeCreditsArea);
            
            htmlBody.html(textString).on("click",removeInfoArea);

	        creditsIsVisible = true;
		
		} else {

			removeCreditsArea();
			creditsIsVisible = false;

		}

	}

	function removeCreditsArea(){

		container.selectAll(".credits").remove();
		creditsIsVisible = false;

    }
        
            
        
    //---------------- plane support functions ----------------//
        
        
    function getRandomIntInRange(min, max) {
        min = Math.ceil(min);
        max = Math.ceil(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
        
    function generateIntArrayWithRange(start, end) {
        var array = [];
        for(var i=start; i<=end; i++) {
            array.push(i);
        }
        return array;
    }
        
    function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;

        while (0 !== currentIndex) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    }
        
    function centerRectX(x) {
        return x - cluster_rect_width/2;
    }
        
    function centerRectY(y) {
        return y - cluster_rect_height/2;
    }

    function codeToRealHue(number){
        if(number + nodeHue > hueRange) {
            return number + nodeHue - hueRange;
        } else {
            return number + nodeHue;
        }
    }

    function generateColors(amount) {
        var colorList = [];
        var step = hueRange/(amount+1); 
        for(i=1; i<=amount; i++) {
            var coded = codeToRealHue(step*(i));
            colorList.push("hsl("+coded+", "+clusterSaturation+"%, "+lightness+"%)");
        }
        return colorList;
    }
        
        
    //---------------- plane ----------------//
        
        
    var id2plane = {};
    
    // this class represent a logical plane, through which we're going to display a cluster's elements
    class Plane {

        constructor(this_node, element_list, is_root_node) {
            this.node = this_node;
            this.numberOfElements = element_list.length;
            this.elements = element_list;
            this.elementCoords = this.generateElementsCoords();
            this.is_root_node = is_root_node;
            this.isDisplayed = true;
        }
        
        generateElementsCoords() {
            var element2coords = [];
            var Xcoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            var Ycoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            for(var i=0; i<this.numberOfElements; i++) {
                var x = Xcoords[i];
                var y = Ycoords[i];
                element2coords[i] = [x,y];
            }
            return element2coords;
        }
        
        countClusterChildren() {
            var count = 0;
            this.elements.forEach(function(d, i) {
                if(d[0]!=null) {
                    count += 1;
                }
            });
            return count;
        }
        
        displayChildren() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;
            
            var colorList;
            var num_of_cluster_children = this.countClusterChildren();
            if(this.is_root_node) {
                colorList = generateColors(num_of_cluster_children);
            } else {
                var color = this.node.attributes.fill.value;
                colorList = [];
                for(i=0; i<num_of_cluster_children; i++) {
                    colorList.push(color);
                }
            }
            
            var j=0;
            this.elements.forEach(function(d, i) {
                var childId = thisId+","+i;
                if(d[0]!=null){
                    var child_node = workarea
                        .append("rect")
                        .attr("id",childId)
                        .attr("class","cluster_node")
                        .attr("x", centerRectX(x + (this.elementCoords[i][0] - 1) * distance))
                        .attr("y", centerRectY(y + (this.elementCoords[i][1] - 1) * distance))
                        .attr("rx", 10)
                        .attr("ry", 10)
                        .attr("width", cluster_rect_width)
                        .attr("height", cluster_rect_height)
                        .attr("fill", colorList[j])
                        .attr("stroke-width", 2)
                        .attr("stroke", "black")
                        .on("click", explode)
                        ._groups[0][0];
                    // I need to update the child cluster's plane node if it already exists
                    if(id2plane.hasOwnProperty(childId)) {
                        id2plane[childId].node = child_node;
                    }
                    j+=1;
                }
                else {
                    var node = workarea
                        .append("g")
                        .attr("id",childId)
                        //.attr("class","node")
                        .attr("info", d)
                        .on("click", info);
                    node
                        .append("circle")
                        .attr("id",childId)
                        .attr("class","circle")
                        .attr("cx", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("cy", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("r", node_circle_r)
                        .attr("info", d)
                        .attr("fill", "hsl("+nodeHue+", "+nodeSaturation+"%, "+lightness+"%)")
                        .attr("stroke-width", 2)
                        .attr("stroke", "black");
                    node
                        .append("text")
                        .attr("id",childId)
                        .attr("class","node")
                        .attr("x", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("y", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("font-family","sans-serif")
                        .style("text-anchor", "middle")
                        .text(d)
                        .style("font-size", function(d) {
                            var d2csf = 1/Math.sqrt(2);  // d2csf = diameter_2_circumscribed_square_factor
                            var v1 = 2*node_circle_r * d2csf;
                            var v2 = (v1 / this.getComputedTextLength() * 24) * d2csf;
                            return Math.min(v1, v2) + "px";
                        })
                        .attr("dy", ".35em");
                }
            }, this);
        }
        
        getParentOpacity(thisId) {
            var i = thisId.lastIndexOf(",");
            var parentId = thisId.substring(0, i);
            if(parentId != "0") {
                return workarea.select("[id='"+parentId+"']").attr("fill-opacity");
            } else {
                return 0;
            } 
        }
        
        displayBackgroundCluster() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;
            var color = this.node.attributes.fill.value;
            var opacity = this.getParentOpacity(thisId);
            if(opacity == 0) {
                opacity = base_bg_opacity;
            } else {
                opacity = opacity * bg_opacity_decay;
            }
            
            return workarea
                .append("rect")
                .attr("id",thisId)
                .attr("class","cluster_bg")
                .attr("x", x - distance/2)
                .attr("y", y - distance/2)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", this.elementCoords.length * distance)
                .attr("height", this.elementCoords.length * distance)
                .attr("fill", color)
                .attr("fill-opacity", opacity)
                .attr("stroke-width", 2)
                .attr("stroke", color)
                .attr("stroke-opacity", opacity * 2)
                .on("dblclick", implode);
        }
        
        getParentClustersIds(thisId) {
            var clusterIds = [];
            while(thisId.includes(",")) {
                var i = thisId.lastIndexOf(",");
                thisId = thisId.substring(0, i);
                if(thisId != "0") { clusterIds.push(thisId); }
            }
            return clusterIds;
        }
        
        updateOtherCoordsAfterExplode() {
            var thisId = this.node.attributes.id.value;
            var this_x = parseInt(this.node.attributes.x.value);
            var this_y = parseInt(this.node.attributes.y.value);
            var delta = (this.elementCoords.length-1) * distance;
            
            var toTranslate = workarea.selectAll("*").filter(function() {
                var elem = d3.select(this);
                var is_of_right_class = elem.attr("class") === "node" || elem.attr("class") === "cluster_node" || elem.attr("class") === "circle" || elem.attr("class") === "cluster_bg";
                return is_of_right_class && !elem.attr("id").startsWith(thisId);
            });
            toTranslate.attr("x", function(d, i) {
                var xStr = d3.select(this).attr("x");
                if(xStr === null) { // if it's null it's because it's a circle!
                    var cx = parseInt(d3.select(this).attr("cx"));
                    if(cx > this_x) { d3.select(this).attr("cx", cx + delta); }
                    return xStr;
                }
                var x = parseInt(xStr);
                if(x > this_x) { return x + delta; }
                else { return x; }  
            }).attr("y", function(d, i) {
                var yStr = d3.select(this).attr("y");
                if(yStr === null) {
                    var cy = parseInt(d3.select(this).attr("cy"));
                    if(cy > this_y) { d3.select(this).attr("cy", cy + delta); }
                    return yStr;
                }
                var y = parseInt(d3.select(this).attr("y"));
                if(y > this_y) { return y + delta; }
                else { return y; }  
            })
            
            // I also need to enlarge the parent cluster(s) 
            var parentIds = this.getParentClustersIds(thisId);
            parentIds.forEach(function(id, i) {
                var parent = d3.select("[id='"+id+"']");
                parent.attr("width", parseInt(parent.attr("width"))+delta);
                parent.attr("height", parseInt(parent.attr("height"))+delta);
            });
            
        }
        
        getDisplayedChildrenClustersAddedSize(thisId) {
            var totalAddedSize = 0;
            for(var id in id2plane) {
                var child =id2plane[id];
                if(id != thisId && id.startsWith(thisId) && child.isDisplayed) {
                    var addedSize = (child.elementCoords.length-1) * distance;
                    totalAddedSize += addedSize;
                    child.isDisplayed = false;  // this child will be closed!
                }
            }
            return totalAddedSize;
        }
        
        updateOtherCoordsAfterImplode() {
            var thisId = this.node.attributes.id.value;
            var this_x = parseInt(this.node.attributes.x.value);
            var this_y = parseInt(this.node.attributes.y.value);
            var delta = (this.elementCoords.length-1) * distance;
            delta += this.getDisplayedChildrenClustersAddedSize(thisId);
            
            var toTranslate = workarea.selectAll("*").filter(function() {
                var elem = d3.select(this);
                var is_of_right_class = elem.attr("class") === "node" || elem.attr("class") === "cluster_node" || elem.attr("class") === "circle" || elem.attr("class") === "cluster_bg";
                return is_of_right_class && !elem.attr("id").startsWith(thisId);
            })
            toTranslate.attr("x", function(d, i) {
                var xStr = d3.select(this).attr("x");
                if(xStr === null) {
                    var cx = parseInt(d3.select(this).attr("cx"));
                    if(cx > this_x) { d3.select(this).attr("cx", cx - delta); }
                    return xStr;
                }
                var x = parseInt(xStr);
                if(x > this_x) { return x - delta; }
                else { return x; }  
            }).attr("y", function(d, i) {
                var yStr = d3.select(this).attr("y");
                if(yStr === null) {
                    var cy = parseInt(d3.select(this).attr("cy"));
                    if(cy > this_y) { d3.select(this).attr("cy", cy - delta); }
                    return yStr;
                }
                var y = parseInt(d3.select(this).attr("y"));
                if(y > this_y) { return y - delta; }
                else { return y; }  
            })
            
            // I also need to reduce the parent cluster(s) size
            var parentIds = this.getParentClustersIds(thisId);
            parentIds.forEach(function(id, i) {
                var parent = d3.select("[id='"+id+"']");
                parent.attr("width", parseInt(parent.attr("width"))-delta);
                parent.attr("height", parseInt(parent.attr("height"))-delta);
            });
        }
        
        displayPlane() {
            // if this is the root cluster node
            if(this.is_root_node) {
                this.displayChildren()
                panAndZoomToRootPlaneCenter(this)
                
            // if this is NOT the root cluster node
            } else {
                var bg = this.displayBackgroundCluster();
                this.displayChildren();
            }
            if(!this.is_root_node) {
                this.updateOtherCoordsAfterExplode();
                if(panOnExplode) {
                    panToElement(bg);
                }
            }
            this.isDisplayed = true;
        }
        
        hidePlane() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(workarea.select("[id='"+thisId+"']").attr("x")) + distance/2 - cluster_rect_width/2;
            var y = parseInt(workarea.select("[id='"+thisId+"']").attr("y")) + distance/2 - cluster_rect_height/2;
            var color = this.node.attributes.fill.value;
            workarea.selectAll("[id^='"+thisId+"']").remove();
            
            var new_node = workarea.append("rect")
                .attr("id",thisId)
                .attr("class","cluster_node")
                .attr("x", x)
                .attr("y", y)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", cluster_rect_width)
                .attr("height", cluster_rect_height)
                .attr("fill", color)
                .attr("stroke-width", 2)
                .attr("stroke", "black")
                .on("click", explode);
            
            this.node = new_node._groups[0][0];
            
            this.updateOtherCoordsAfterImplode();
            if(panOnImplode) {
                panToElement(new_node);
            }
            this.isDisplayed = false;
        }
        
    }
        
        
        
    //---------------- main ----------------//

	
    var graph = [];
    var numbers = [];
    var edges = new Map();
    var cluster2nodeNumbers = {};
    var nodeNumber2elementId = {};

    function resetGlobalVariables(){
        graph = [];
        numbers = [];
        edges = new Map();
        cluster2nodeNumbers = {};
        nodeNumber2elementId = {};
        id2plane = {};
    }

    d3.selection.prototype.moveToFront = function() {  
      return this.each(function(){
        this.parentNode.appendChild(this);
      });
    };
    d3.selection.prototype.moveToBack = function() {  
        return this.each(function() { 
            var firstChild = this.parentNode.firstChild; 
            if (firstChild) { 
                this.parentNode.insertBefore(this, firstChild); 
            } 
        });
    };

    loadGraph(defaultGraph);

    function downloadGraph(){

	    function download(content, fileName, contentType) {
		    var a = document.createElement("a");
		    var file = new Blob([content], {type: contentType});
		    a.href = URL.createObjectURL(file);
		    a.download = fileName;
		    a.click();
		}

    	download(JSON.stringify(currentJson, null, 4), 'graph.json', 'application/json');

    }

    function loadGraph(file){

        resetGlobalVariables();
	    var promises = [];

	    file.forEach(function(url) {
	        promises.push(d3.json(url))
	    });

	    Promise.all(promises).then(function(values) {
            currentJson = values[0];
	        graph[0] = values[0].clusters;
	        edges = values[0].edges;
	        buildCluster2nodeNumbers();
	        buildNodeNumber2element();
	        workarea.selectAll(".rect")
	            .data(values[0].clusters)
	            .enter()
	            .append("g")
	            .attr("id",0)
	            .attr("class","plane")
	            .attr("x", workarea_center_x)
	            .attr("y", workarea_center_y)
	        var thisId = "0";
	        var thisIdAsPath = [0];
	        var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);
	        var this_node = workarea.select("[id='"+thisId+"']")._groups[0][0];
	        var plane = new Plane(this_node,thisJsonSubtree,true);
	        id2plane[thisId] = plane;
	        plane.displayPlane();
	        numbers = buildNumbersList();
	        drawAllEdges();
	    });
	}

    //--------------------------------------//

    function drawEdgeByCoordinates(x1,y1,x2,y2,startIsCircle,endIsCircle){
        var xDirection = 0, yDirection = 0;
        if(x1 - x2 > 0) {
            xDirection = -1;
        } else if (x2 - x1 > 0) {
            xDirection = +1;
        }
        if(y1 - y2 > 0) {
            yDirection = +1;
        } else if (y2 - y1 > 0) {
            yDirection = -1;
        }
        
        var drawEdge = function(d) {
                var curveDistance = distance/2.5;

                var curve_x2 = d.x1 + d.xDir * curveDistance;
                var curve_y2 = d.y2;
            
                var edge = d3.path();
                if(d.startIsCircle) {
                    edge.moveTo(d.x1, d.y1 - d.yDir * (node_circle_r + 1));
                } else {
                    edge.moveTo(d.x1, d.y1 - d.yDir * (cluster_rect_height/2 + 1));
                }
                edge.lineTo(d.x1, d.y2 + d.yDir * curveDistance);
                edge.quadraticCurveTo(d.x1, d.y2, curve_x2, curve_y2);
                if(d.endIsCircle) {
                    edge.lineTo(d.x2 - d.xDir * (node_circle_r + 1), d.y2);
                } else {
                    edge.lineTo(d.x2 - d.xDir * (cluster_rect_width/2 + 1), d.y2);
                }

                return edge;
            }
        
        if(xDirection != 0 && yDirection != 0) {

            var coords = {};
            coords["x1"] = x1;
            coords["y1"] = y1;
            coords["x2"] = x2;
            coords["y2"] = y2;
            coords["xDir"] = xDirection;
            coords["yDir"] = yDirection;
            coords["startIsCircle"] = startIsCircle;
            coords["endIsCircle"] = endIsCircle;
            
            workarea.append("path")
                .attr("d", drawEdge(coords))
                .attr("fill","none")
                .attr("stroke","black")
                .attr("stroke-width","2")
                .attr("class","edge");
            
            var xTriPoint,yTriPoint,xTriUp,yTriUp,xTriBottom,yTriBottom;
            
            if(endIsCircle) {
                xTriPoint = x2 - xDirection * (node_circle_r + 1);
            } else {
                xTriPoint = x2 - xDirection * (cluster_rect_width/2 + 1);
            }
            yTriPoint = y2;
            yTriUp = yTriPoint - 7;
            yTriBottom = yTriPoint + 7;
            xTriUp = xTriPoint - xDirection * 10;
            xTriBottom = xTriPoint - xDirection * 10;

            var Tri = workarea
                .append("polygon")
                .attr("class","edge")
                .attr("fill","black")
                .attr("stroke","black")
                .attr("stroke-width","2")
                .attr("points",
                    xTriPoint+","+yTriPoint+" "+
                    xTriUp+","+yTriUp+" "+
                    xTriBottom+","+yTriBottom);
        }
        
    }

    function drawEdgeByNodes(startId,endId){
        var x1,y1,x2,y2;
        var endIsCircle = true;
        var startIsCircle = true;
        if(cluster2nodeNumbers.hasOwnProperty(startId)){
            startIsCircle = false;
            var startNode = workarea.select("[id='"+startId+"']")._groups[0][0];
            x1 = parseInt(startNode.attributes.x.value) + cluster_rect_width/2;
            y1 = parseInt(startNode.attributes.y.value) + cluster_rect_height/2;
        }else{
            var startNode = workarea.select("[id='"+startId+"']").select(".circle")._groups[0][0];
            x1 = parseInt(startNode.attributes.cx.value);
            y1 = parseInt(startNode.attributes.cy.value);
        }
        if(cluster2nodeNumbers.hasOwnProperty(endId)){
        	endIsCircle = false;
            var endNode = workarea.select("[id='"+endId+"']")._groups[0][0];
            x2 = parseInt(endNode.attributes.x.value) + cluster_rect_width/2;
            y2 = parseInt(endNode.attributes.y.value) + cluster_rect_height/2;
        }else{      	
            var endNode = workarea.select("[id='"+endId+"']").select(".circle")._groups[0][0];
            x2 = parseInt(endNode.attributes.cx.value);
            y2 = parseInt(endNode.attributes.cy.value);
        }
        drawEdgeByCoordinates(x1,y1,x2,y2,startIsCircle,endIsCircle);
    }

    function drawAllEdges(){
        numbers.forEach(function(nodeNumber, i){
            if(edges[nodeNumber]!=null){
                edges[nodeNumber].forEach(function(edgeEnd, i) {
                    var startId = nodeNumber2elementId[nodeNumber];
                    var endId = nodeNumber2elementId[edgeEnd];
                    drawEdgeByNodes(startId,endId);
                });
            }
        });
    }

    function buildNumbersList(){
        var clusterElements = d3.selectAll(".cluster_node")._groups[0];
        var clusterIds = [];
        var numbers = [];
        clusterElements.forEach(function(cluster, i) {
            clusterIds.push(cluster.attributes.id.value);
        });
        clusterIds.forEach(function(clusterid, i) {
            cluster2nodeNumbers[clusterid].forEach(function(nodeNumber, i) {
                numbers.push(nodeNumber);
            });
        });
        var circleElements = d3.selectAll(".circle")._groups[0];
        circleElements.forEach(function(circle, i) {
            numbers.push(parseInt(circle.attributes.info.value));
        });
        return numbers;
    }


    //--------------------------------------//
        
    function clusterIdsDfs(idStrOld, clusterIds) {
        var children = retrieveElementFromGraphByPathId(idStringToList(idStrOld));
        children.forEach(function(child, i) {
            if(child[0]!=null) {
                var idStr = idStrOld+","+i;
                clusterIds.push(idStr);
                clusterIdsDfs(idStr, clusterIds);
            }
        });
    }
        
    function findAllClusterIds() {
        var clusterIds = [];
        clusterIds.push("0");
        var children = retrieveElementFromGraphByPathId([0]);
        children.forEach(function(child, i) {
            if(child[0]!=null) {
                var idStr = "0,"+i;
                clusterIds.push(idStr);
                clusterIdsDfs(idStr, clusterIds);
            }
        });
        return clusterIds;
    }
        
    function nodeNumbersDfs(idStrOld, nodeNumbers) {
        var children = retrieveElementFromGraphByPathId(idStringToList(idStrOld));
        children.forEach(function(child, i) {
            if(child[0]!=null) {
                var idStr = idStrOld+","+i;
                nodeNumbersDfs(idStr, nodeNumbers);
            } else {
                nodeNumbers.push(child);
            }
        });
    }
        
    function findAllNodeNumbersInside(clusterId) {
        var nodeNumbers = [];
        var children = retrieveElementFromGraphByPathId(idStringToList(clusterId));
        children.forEach(function(child, i) {
            if(child[0]!=null) {
                var idStr = clusterId+","+i;
                nodeNumbersDfs(idStr, nodeNumbers);
            } else {
                nodeNumbers.push(child);
            }
        });
        return nodeNumbers;
    }
        
    function buildCluster2nodeNumbers() {
        var clusterIds = findAllClusterIds();
        clusterIds.forEach(function (clusterId,i) {
            var nodeNumbers = findAllNodeNumbersInside(clusterId);
            cluster2nodeNumbers[clusterId] = nodeNumbers;
        });
    }
        
    //--------------------------------------//
        
    function updateNN2EafterExplode(explodedClusterId) {
         var children = retrieveElementFromGraphByPathId(idStringToList(explodedClusterId));
         children.forEach(function(child, i) {
            var idStr = explodedClusterId+","+i;
            var nodeNumbers = [];
            if(cluster2nodeNumbers.hasOwnProperty(idStr)) {
                nodeNumbers = cluster2nodeNumbers[idStr];
            } else {
                nodeNumbers.push(retrieveElementFromGraphByPathId(idStringToList(idStr)));
            }
            nodeNumbers.forEach(function(nodeNumber, i) {
                nodeNumber2elementId[nodeNumber] = idStr;
            });
         });
    }
        
    function updateNN2EafterImplode(implodedClusterId) {
        var nodeNumbers = cluster2nodeNumbers[implodedClusterId];
        nodeNumbers.forEach(function(nodeNumber, i) {
            nodeNumber2elementId[nodeNumber] = implodedClusterId;
        });
    }
        
    function buildNodeNumber2element() {
        var children = retrieveElementFromGraphByPathId([0]);
        children.forEach(function(child, i) {
            var idStr = "0,"+i;
            var nodeNumbers = [];
            if(cluster2nodeNumbers.hasOwnProperty(idStr)) {
                nodeNumbers = cluster2nodeNumbers[idStr];
            } else {
                nodeNumbers.push(retrieveElementFromGraphByPathId(idStringToList(idStr)));
            }
            nodeNumbers.forEach(function(nodeNumber, i) {
                nodeNumber2elementId[nodeNumber] = idStr;
            });
        });
    }    
    
    //--------------------------------------//

	function retrieveElementFromGraphByPathId(path){   //path as to be list: [0,1,0]
		var i = 0;
		var g = graph[0];
		while (path[i]!=null) {
			if(path.length==i+1){
				return g[path[i]];
			}
			else {
				g = g[path[i]];
				i=i+1;
			}
		}
		return null;
	}

	function idStringToList(string){
		var i = 0;
		var list = [];
		var buffer = "";
		while (string[i]!=null){
			if(string[i]!=","){
				buffer = buffer + string[i]
			}
			else {
				list.push(buffer);
				buffer = "";
			}
			i=i+1;
		}
		list.push(buffer);
		return list;
	}

	function info(){
		console.log(this.attributes.id.value+"; "+this.attributes.info.value);
	}

	function explode(event){
		var thisId = this.attributes.id.value;
		var thisIdAsPath = idStringToList(thisId);
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);

        if(!id2plane.hasOwnProperty(thisId)) {
            var plane = new Plane(this,thisJsonSubtree,false);
            id2plane[thisId] = plane;
            plane.displayPlane();
        } else {
            var plane = id2plane[thisId];
            plane.displayPlane();
        }
		this.remove();
        updateNN2EafterExplode(thisId);
        workarea.selectAll(".edge").remove();
        drawAllEdges();
	}
                
    function implode(event){
        var thisId = this.attributes.id.value;

		plane = id2plane[thisId];
        plane.hidePlane();
        updateNN2EafterImplode(thisId);
        workarea.selectAll(".edge").remove();
        drawAllEdges();
    }
        
        
        
    //---------------- animations ----------------//
        
        
    function panToElement(elem) {
        var x = parseInt(elem.attr("x"));
        var y = parseInt(elem.attr("y"));
        var width = parseInt(elem.attr("width"));
        var height = parseInt(elem.attr("height"));
        
        var tx = (-width/2 - x) * currentZoomScale + container.attr("width")/2;
        var ty = (-height/2 - y) * currentZoomScale + container.attr("height")/2;
                          
        workarea.transition()
            .duration(animations_duration)
            .attr("transform", "translate("+tx+","+ty+")scale("+currentZoomScale+")")
            .on("end", function() {
                container.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(currentZoomScale));
            });
    }
        
    function panToRootPlaneCenter(rootPlane) {
        
        var x = parseInt(rootPlane.node.attributes.x.value);
        var y = parseInt(rootPlane.node.attributes.y.value);
        var width = rootPlane.elementCoords.length * distance;
        var height = rootPlane.elementCoords.length * distance;

        var tx = (-width/2 - x) * currentZoomScale + container.attr("width")/2;
        var ty = (-height/2 - y) * currentZoomScale + container.attr("height")/2;
                          
        workarea.transition()
            .duration(animations_duration)
            .attr("transform", "translate("+tx+","+ty+")scale("+currentZoomScale+")")
            .on("end", function() {
                container.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(currentZoomScale));
            });    
    }
        
    function panAndZoomToRootPlaneCenter(rootPlane) {
        
        var x = parseInt(rootPlane.node.attributes.x.value);
        var y = parseInt(rootPlane.node.attributes.y.value);
        var width = rootPlane.elementCoords.length * distance;
        var height = rootPlane.elementCoords.length * distance;
        
        currentZoomScale = Math.min(container.attr("width")/(width + 2*distance), container.attr("height")/(height + 2*distance))

        var tx = (-width/2 - x) * currentZoomScale + container.attr("width")/2;
        var ty = (-height/2 - y) * currentZoomScale + container.attr("height")/2;
                          
        workarea.transition()
            .duration(animations_duration)
            .attr("transform", "translate("+tx+","+ty+")scale("+currentZoomScale+")")
            .on("end", function() {
                container.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(currentZoomScale));
            });    
    }
        
    function updateZoomScaleAfterWindowResize(oldWidth, oldHeight, newWidth, newHeight) {
        currentZoomScale = Math.min(newWidth/oldWidth, newHeight/oldHeight);
        
        workarea.transition()
            .duration(animations_duration)
            .attr("transform", "scale("+currentZoomScale+")")
            .on("end", function() {
                container.call(zoom.transform, d3.zoomIdentity.scale(currentZoomScale));
            });    
    }
        
    // WIP
    function panAndZoomToCurrentWorkareaCenter(oldWidth, oldHeight, newWidth, newHeight) {
        
        var x = workarea.attr("x"); // THIS DOESN'T WORK! T-T
        var y = workarea.attr("y"); // THIS DOESN'T WORK! T-T
        
        console.log(x);
        console.log(y);
        
        currentZoomScale = Math.min(newWidth/oldWidth, newHeight/oldHeight);

        var tx = (-oldWidth/2 - x) * currentZoomScale + newWidth/2;
        var ty = (-oldHeight/2 - y) * currentZoomScale + newHeight/2;
                          
        workarea.transition()
            .duration(animations_duration)
            .attr("transform", "translate("+tx+","+ty+")scale("+currentZoomScale+")")
            .on("end", function() {
                container.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(currentZoomScale));
            });    
    }

	</script>
</body>
</html>