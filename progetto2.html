<!DOCTYPE html>
<html>
<head>
	<title>progetto2</title>
	<meta charset="utf-8">
	<script type="text/javascript" src="d3/d3.min.js"></script>
</head>
<body>
	<script type="text/javascript">

	const workarea_width = 1600;
	const workarea_height = 900;
	const workarea_center_x = workarea_width/2;
	const workarea_center_y = workarea_height/2;
        
	const distance = 100;
    const cluster_rect_width = 60;
    const cluster_rect_height = 60;
    const node_circle_r = 20;  // -> diameter is 2*r
    const cluster_background_opacity = 0.1
    
    //--------------------------//
    
    var container = d3.select("body")
		.append("svg")
		.attr("width", workarea_width).attr("height", workarea_height)
        .attr("style", "outline: medium solid black;")
        .call(d3.zoom().on("zoom", function () {
            workarea.attr("transform", d3.event.transform);
        }))
        .on("dblclick.zoom", null);
        
	var workarea = container.append("g");
        
    function resize_container() {
        container.attr("width", window.innerWidth-20).attr("height", window.innerHeight-20);
    }
        
    resize_container();
        
    window.addEventListener("resize", resize_container);
        
    //--------------------------//
        
    function getRandomIntInRange(min, max) {
        min = Math.ceil(min);
        max = Math.ceil(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
        
    function generateIntArrayWithRange(start, end) {
        var array = [];
        for(var i=start; i<=end; i++) {
            array.push(i);
        }
        return array;
    }
        
    function shuffle(array) {
        var currentIndex = array.length, temporaryValue, randomIndex;

        while (0 !== currentIndex) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;

            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }

        return array;
    }
        
    function centerRectX(x) {
        return x - cluster_rect_width/2;
    }
        
    function centerRectY(y) {
        return y - cluster_rect_height/2;
    }
        
    // gets font size based on text and container element size
    function getSize(d) {
        var bbox = this.getBBox();
        var cbbox = this.parentNode.getBBox();
        console.log("cbbox: " + this.parentNode + ", size: "+ cbbox.width + " " + cbbox.height);
        console.log("bbox: " + bbox.width + " " + bbox.height);
        var scale = Math.min(cbbox.width/bbox.width, cbbox.height/bbox.height);
        console.log("scale: " + scale);
        d.scale = scale;
    }

    //--------------------------//
        
    var id2plane = {};
    
    // this class represent a logical plane, through which we're going to display a cluster's elements
    class Plane {

        constructor(this_node, element_list, is_root_node) {
            this.node = this_node;
            this.numberOfElements = element_list.length;
            this.elements = element_list;
            this.elementCoords = this.generateElementsCoords();
            this.is_root_node = is_root_node;
        }
        
        generateElementsCoords() {
            var element2coords = [];
            var Xcoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            var Ycoords = shuffle(generateIntArrayWithRange(1,this.numberOfElements));
            for(var i=0; i<this.numberOfElements; i++) {
                var x = Xcoords[i];
                var y = Ycoords[i];
                element2coords[i] = [x,y];
            }
            return element2coords;
        }
        
        displayChildren() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;

            this.elements.forEach(function(d, i) {
                console.log(d + " " + i);
                if(d[0]!=null){
                    workarea
                        .append("rect")
                        .attr("id",thisId+","+i)
                        .attr("class","cluster_node")
                        .attr("x", centerRectX(x + (this.elementCoords[i][0] - 1) * distance))
                        .attr("y", centerRectY(y + (this.elementCoords[i][1] - 1) * distance))
                        .attr("rx", 10)
                        .attr("ry", 10)
                        .attr("width", cluster_rect_width)
                        .attr("height", cluster_rect_height)
                        .attr("fill", "red")
                        .attr("stroke-width", 2)
                        .attr("stroke", "black")
                        .on("click", explode);
                }
                else {
                    var node = workarea
                        .append("g")
                        .attr("id",thisId+","+i)
                        .attr("class","node")
                        .attr("info", d)
                        .on("click", info);
                    node
                        .append("circle")
                        //.attr("id",thisId+","+i)
                        //.attr("class","node")
                        //.attr("info", d)
                        .attr("cx", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("cy", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("r", node_circle_r)
                        .attr("fill", "yellow")
                        .attr("stroke-width", 2)
                        .attr("stroke", "black")
                        //.on("click", info);
                    node
                        .append("text")
                        //.attr("id",thisId+","+i)
                        .attr("x", x + (this.elementCoords[i][0] - 1) * distance)
                        .attr("y", y + (this.elementCoords[i][1] - 1) * distance)
                        .attr("font-family","sans-serif")
                        .style("text-anchor", "middle")
                        .text(d)
                        .style("font-size", function(d) {
                            var d2csf = 1/Math.sqrt(2);  // d2csf = diameter_2_circumscribed_square_factor
                            var v1 = 2*node_circle_r * d2csf;
                            var v2 = (v1 / this.getComputedTextLength() * 24) * d2csf;
                            console.log("v1=" + v1 + "   v2=" + v2);
                            console.log("min=" + Math.min(v1, v2));
                            return Math.min(v1, v2) + "px";
                        })
                        .attr("dy", ".35em");
                }
            }, this);
        }
        
        displayBackgroundCluster() {
            var thisId = this.node.attributes.id.value;
            var x = parseInt(this.node.attributes.x.value) + cluster_rect_width/2;
            var y = parseInt(this.node.attributes.y.value) + cluster_rect_height/2;
            workarea
                .append("rect")
                .attr("id",thisId)
                .attr("class","cluster_bg")
                .attr("x", x - distance/2)
                .attr("y", y - distance/2)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", this.elementCoords.length * distance)
                .attr("height", this.elementCoords.length * distance)
                .attr("fill", "blue")
                .attr("fill-opacity", cluster_background_opacity)
                .attr("stroke-width", 2)
                .attr("stroke", "black")
                .on("dblclick", implode);
        }
        
        displayPlane() {
            // if this is the root cluster node
            if(this.is_root_node) {
                this.displayChildren()
                
            // if this is NOT the root cluster node
            } else {
                this.displayBackgroundCluster();
                this.displayChildren();
            }
        }
        
        hidePlane() {
            var thisId = this.node.attributes.id.value;
            workarea.selectAll("[id^='"+thisId+"']").remove();
            
            var x = parseInt(this.node.attributes.x.value);
            var y = parseInt(this.node.attributes.y.value);
            workarea.append("rect")
                .attr("id",thisId)
                .attr("class","cluster_node")
                .attr("x", x)
                .attr("y", y)
                .attr("rx", 10)
                .attr("ry", 10)
                .attr("width", cluster_rect_width)
                .attr("height", cluster_rect_height)
                .attr("fill", "red")
                .attr("stroke-width", 2)
                .attr("stroke", "black")
                .on("click", explode);
        }
        
    }
        
    //--------------------------//

	
	var graph = [];
	d3.json("clusters.json").then(function(data) {
		console.log(data);
		graph[0] = data;
		console.log(graph);
		workarea.selectAll(".rect")
			.data(data)
			.enter()
            .append("g")
            .attr("id",0)
            .attr("class","plane")
            .attr("x", workarea_center_x)
			.attr("y", workarea_center_y)
        var thisId = "0";
		var thisIdAsPath = [0];
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);
        var this_node = workarea.select("[id='"+thisId+"']")._groups[0][0];
		var plane = new Plane(this_node,thisJsonSubtree,true);
        id2plane[thisId] = plane;
		plane.displayPlane();
    });

	function retrieveElementFromGraphByPathId(path){   //path as to be list: [0,1,0]
		var i = 0;
		var g = graph[0];
		while (path[i]!=null) {
			if(path.length==i+1){
				return g[path[i]];
			}
			else {
				g = g[path[i]];
				i=i+1;
			}
		}
		return null;
	}

	function idStringToList(string){
		var i = 0;
		var list = [];
		var buffer = "";
		while (string[i]!=null){
			if(string[i]!=","){
				buffer = buffer + string[i]
			}
			else {
				list.push(buffer);
				buffer = "";
			}
			i=i+1;
		}
		list.push(buffer);
		return list;
	}

	function info(){
		console.log(this.attributes.id.value+";"+this.attributes.x.value+","+this.attributes.y.value+";"+this.attributes.info.value);
	}

	function explode(event){
		var thisId = this.attributes.id.value;
		var thisIdAsPath = idStringToList(thisId);
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);

        if(!id2plane.hasOwnProperty(thisId)) {
            var plane = new Plane(this,thisJsonSubtree,false);
            id2plane[thisId] = plane;
            plane.displayPlane();
        } else {
            var plane = id2plane[thisId];
            plane.displayPlane();
        }
		this.remove();
	}
                
    function implode(event){
        var thisId = this.attributes.id.value;
		var thisIdAsPath = idStringToList(thisId);
		var thisJsonSubtree = retrieveElementFromGraphByPathId(thisIdAsPath);

		plane = id2plane[thisId];
        plane.hidePlane();
    }

	</script>
</body>
</html>